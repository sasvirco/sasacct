#!/usr/bin/perl -w
# Author Aleksandar Zheliazkov ; sasvirco@homemail.com
use strict;
use Carp;
use Time::localtime qw (:FIELDS);
use Sys::Syslog qw(:DEFAULT setlogsock);
use Getopt::Std;
use File::Basename;

my ( $name, $path ) = fileparse($0);
my %rkeys;     #required keys
my %local;     #local machine vars(ip,description)
my @remote;    #contains the remote machines running sasacct via inetd
my $now         = localtime();
my $system_time = sprintf(
    "%04d%02d%02d% 02d%02d%02d",
    $tm_year + 1900,
    $tm_mon + 1,
    $tm_mday, $tm_hour, $tm_min, $tm_sec
);
my ( %traffin, %traffout );
my $configfile;
my $userrd;    #flag for using rrd at all
my $logrrd;    #flag for using rrd but don't generate graphs
my $debug = 0; # debug turned over by default use -d for full debug in syslog
my $inetd = 0; # inetd use turned off by default
my $bits  = 1; #use 0 for Bytes per Second and 1 for Bits Per Second
my $lang;      #language locale

#locale section (default)
my %locale = (
    'day'                  => 'Daily',
    'week'                 => 'Weekly',
    'month'                => 'Montly',
    'year'                 => 'Yearly',
    'vertical-label-bits'  => 'Bits per second',
    'vertical-label-bytes' => 'Bytes per second',
    'in'                   => 'In',
    'average'              => 'Avg',
    'min'                  => 'Min',
    'max'                  => 'Max',
    'out'                  => 'Out',
    'current'              => 'Cur',
    'comment' => 'Generated by sasacct http\://rousse.pm.org/sasacct',
    'title'   => 'Traffic Stats'
);

#get LANG from ENV
if ( !exists( $ENV{'LANG'} ) ) {
    $lang = 'C';
}
else {
    $lang = $ENV{'LANG'};
}

# Use syslog for logging
setlogsock('unix');    #requires perl 5.004_02
openlog( 'sasacct', 'cons,pid,nowait', 'user' );

#parse command line args
if ( !defined(@ARGV) ) {
    $userrd = 1;
    $logrrd = 1;
    $inetd  = 0;
}
my %options;
&getopts( 'viedgrhlsc:', \%options );
if ( $options{h} ) {
    &usage;
}
if ( $options{d} ) { $debug = 1; }
if ( $options{i} ) { $inetd = 1; }
syslog( 'info', "sasacct started" ) if ( $debug == 1 );
if ( $options{c} ) {
    $configfile = $options{c};
}
if ( $options{v} ) { &ver; }
if ( $options{l} ) {
    $userrd = 0;
    $logrrd = 0;
}
else {
    $userrd = 1;
    $logrrd = 1;
}
if ( $options{r} ) {
    $logrrd = 1;
    $userrd = 0;
}

# read config
&readconf($configfile);

# check for default language dir
if ( stat( "$path" . "/../lang/$lang" ) ) {
    $rkeys{E} = "$path" . "../lang/";
}

#open the language file and update
#the locale hash with the new values
if ( exists( $rkeys{E} ) && stat( "$rkeys{E}" . "$lang" ) ) {
    open( LANG, "<$rkeys{E}" . "$lang" )
      or carp("Cannot open $rkeys{E}.$lang:$!");
    my ( $descr, $value );
    while (<LANG>) {
        next if $_ =~ /^#/g;
        next if $_ =~ /^\s+/g;
        chomp $_;
        ( $descr, $value ) = split( /=/, $_ );
        $locale{$descr} = $value;
    }
}

if ( $options{s} ) {
    &summarizelogs;
    exit;
}

# check for data directory
if ( !defined( $rkeys{D} ) || !opendir( DIR, $rkeys{D} ) ) {
    syslog( 'info', "directory not found using defaults" );
    mkdir( "/var/sasacct", 0755 );
    syslog( 'info', "/var/sasacct directory created\n" );
    $rkeys{D} = "/var/sasacct";
    closedir DIR;
}

#create graphics only
if ( $options{g} ) {
    &dographonly;
    exit;
}

#get data from remote running sasacct
if ( $options{e} ) {
    &get_remote;
    exit;
}

# Depending on output from different programs accounting,
# make the right decision. There can be one function
# with 4 regexp's but I preffer to split them in
# single functions. The code stays readable and easy to fix.
if ( $rkeys{F} =~ /iptables/ ) {
    &iptables;
    &reset('iptables');
}
elsif ( $rkeys{F} =~ /ipfstat/ ) {
    &ipfstat;
    &reset('ipfstat');
}
elsif ( $rkeys{F} =~ /ipchains/ ) {
    &ipchains;
    &reset('ipchains');
}
elsif ( $rkeys{F} =~ /pfctl/ ) {
    &pf;
    &reset('pf');
}
else {
    croak('Valid F key required. See README for details');
}

########################
# Functions  from here #
########################

###################################################
# readconf($conf) - takes path to config file as an argument
#1. commandline
#2. if !1 then ../etc/sasacct.conf
#3. if !2 && !1 /etc/sasacct.conf

sub readconf($) {
    my ($conf) = @_;
    if ( !defined($conf) ) {
        if ( -f "$path" . "/../etc/sasacct.conf" ) {
            $conf = "$path" . "../etc/sasacct.conf";
        }
        else {
            $conf = '/etc/sasacct.conf';
        }
    }
    open( CNF, "$conf" )
      || croak("sasacct.conf not found use -c option");
    while (<CNF>) {
        if ( $_ =~ /^F/ && !exists( $rkeys{F} ) ) {
            chomp $_;
            s/^F://g;
            $rkeys{F} = $_;
        }
        if ( $_ =~ /^A/ && !exists( $rkeys{A} ) ) {
            chomp $_;
            s/^A://g;
            $rkeys{A} = $_;
        }

        # Check the corect entry for directory
        # If there is slash after it, cut it off and
        # then put it on. I think it's faster than check if
        # there is a /,blah blah else blah blah
        # The same done with all directory entrys.

        if ( $_ =~ /^G/ && !exists( $rkeys{G} ) ) {
            chomp $_;
            s/^G://g;
            s/\/$//g;
            $_ = $_ . "\/";
            $rkeys{G} = $_;
        }
        if ( $_ =~ /^D/ && !exists( $rkeys{D} ) ) {
            chomp $_;
            s/^D://g;
            s/\/$//g;
            $_ = $_ . "\/";
            $rkeys{D} = $_;
        }
        if ( $_ =~ /^I/ ) {
            chomp $_;
            s/^I://g;
            push @remote, $_;
        }
        if ( $_ =~ /^U/ ) {
            chomp $_;
            s/^U://g;
            $lang = $_;
        }
        if ( $_ =~ /^E/ ) {
            chomp $_;
            s/^E://g;
            s/\/$//g;
            $_ = $_ . "\/";
            $rkeys{E} = $_;
        }
        if ( $_ =~ /^L/ ) {
            chomp $_;
            s/^L://g;
            my ( $ip, @i ) = split( /:/, $_ );
            $local{$ip} = \@i if !defined( $local{$ip} );
        }
    }    # end while
    close CNF;
}

########################################################
# Daren Reed's ipf, accounting done trough ipfstat.
# Tested on OpenBSD 2.8 and 2.9, FreeBSD 4.4. Other *BSD
# systems which can use this software (ipf and ipfstat)
# should work too.
#########################################################
#		ipfstat
#

sub ipfstat() {
    open( IN, "$rkeys{F} -ia|" ) || croak('F option incorrect');
    my $line = <IN>;
    while ( defined($line) ) {
        my ( $bytes, $rule, $ia, $on, $iface, $from, $src, $to, $dst ) =
          split( /\s|\t/, $line );
        ( $dst, my $junk ) = split( /\//, $dst );
        $traffin{$dst} = $bytes if exists( $local{$dst} );
        $line = <IN>;
    }
    close IN;
    open( OUT, "$rkeys{F} -oa|" ) || croak('F option incorrect');
    $line = <OUT>;
    while ( defined($line) ) {
        my ( $bytes, $rule, $ia, $on, $iface, $from, $src, $to, $dst ) =
          split( /\s|\t/, $line );
        ( $src, my $junk ) = split( /\//, $src );
        $traffout{$src} = $bytes if exists( $local{$src} );
        $line = <OUT>;
    }

    # We don't update the logfile when the values are zeros
    # because nobody needs zero
    # values and to keep the file small,
    # but it's good to update the rrd file
    # even with zeros, to keep it's internal structure
    # correct. To be removed in future versions
    # because I round the unknown values in the rrd to zero
    my $i;
    my $time = time();
    if ( $userrd == 1 || $logrrd == 1 ) {
        if ( $inetd == 0 ) {
            require 'RRDs.pm';
            my $updaterrd = 1;
            foreach $i ( keys %traffin ) {
                if ( !stat( "$rkeys{D}/$i" . ".rrd" ) ) {
                    &create_file($i);
                    $updaterrd = 0;
                }
                if (   stat( "$rkeys{D}/$i" . ".rrd" )
                    && $updaterrd == 1
                    && $logrrd == 1 )
                {
                    RRDs::update( "$rkeys{D}/$i.rrd",
                        "$time:$traffin{$i}:$traffout{$i}" );
                    syslog( 'info', "updated rrd file for $i" )
                      if ( $debug == 1 );
                }
                graph($i) if ( $userrd == 1 );
            }
        }
    }
    foreach $i ( keys %traffin ) {
        if ( $inetd == 1 ) {
            print STDOUT ("$system_time\t$i\t$traffin{$i}\t$traffout{$i}\n");
        }
        else {
            if ( $traffin{$i} != 0 && $traffout{$i} != 0 ) {
                open( LOG, "+>>$rkeys{D}/$i" )
                  || croak('Cannot open file for writing.Check D option');
                print LOG ("$system_time\t$i\t$traffin{$i}\t$traffout{$i}\n");
                syslog( 'info', "updated info for $i\n" ) if ( $debug == 1 );
            }
        }
    }
    close OUT;
    close LOG;
}

########################################################################################
# Linux 2.4.x
# Add your filtering rules to the SASACCT chain.
# the regexp will match iptables -vxnL line as this:
# 5109  2239346 ACCEPT     all  --  *      *       0.0.0.0/0            195.34.96.192/27
# with or without the target field.
########################################################################################
#			iptables
#
sub iptables() {
    my $regexp =
'(\d+)\s+(\d+)\s+(.*)\s+([\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}[\/]?[\d]{0,2})\s+([\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}[\/]?[\d]{0,2})'
      ;    #whoohaaa what the fuck....@!#$
    open( INOUT, "$rkeys{F} -vxnL SASACCT |" ) || croak('F option incorrect');
    while (<INOUT>) {
        s/^\s+//g;
        if ( $_ =~ /$regexp/g ) {
            my ( $bytes, $src, $dst ) = ( $2, $4, $5 );

            #remove /CIDR from networks
            $src =~ s/\/\d+$//g;
            $dst =~ s/\/\d+$//g;

            #search for ip input traffic

            if ( $local{$dst} ) {
                $traffin{$dst} = $bytes;
            }

            #search for ip output traffic

            if ( $local{$src} ) {
                $traffout{$src} = $bytes;
            }
        }
    }
    my $i;
    my $time = time();
    if ( $userrd == 1 || $logrrd == 1 ) {
        if ( $inetd == 0 ) {
            require 'RRDs.pm';
            my $updaterrd = 1;
            foreach $i ( keys %traffin ) {
                if ( !stat( "$rkeys{D}/$i" . ".rrd" ) ) {
                    &create_file($i);
                    $updaterrd = 0;
                }
                if (   stat( "$rkeys{D}/$i" . ".rrd" )
                    && $updaterrd == 1
                    && $logrrd == 1 )
                {
                    RRDs::update( "$rkeys{D}/$i.rrd",
                        "$time:$traffin{$i}:$traffout{$i}" );
                    syslog( 'info', "updated rrd file for $i" )
                      if ( $debug == 1 );
                }
                graph($i) if ( $userrd == 1 );
            }
        }
    }
    foreach $i ( keys %traffin ) {
        if ( $inetd == 1 ) {
            print STDOUT ("$system_time\t$i\t$traffin{$i}\t$traffout{$i}\n");
        }
        else {
            if ( $traffin{$i} != 0 && $traffout{$i} != 0 ) {
                open( LOG, "+>>$rkeys{D}/$i" )
                  || croak('Cannot open file for writing.Check D option');
                print LOG ("$system_time\t$i\t$traffin{$i}\t$traffout{$i}\n");
                syslog( 'info', "updated info for $i\n" ) if ( $debug == 1 );
            }
        }
    }
    close INOUT;
    close LOG;
}

#################################################################
# Linux 2.2.x. Jump everithing from INPUT and OUTPUT to SASACCTI
# and SASACCTO respectively. Parse SASACCTI and SASACCTO.
#################################################################
#			ipchains
#
sub ipchains() {
    open( IN, "$rkeys{F} -vxnL SASACCTI|" ) || croak('F option incorrect');
    my $line = <IN>;
    while ( defined($line) ) {
        $line =~ s/^\s+|\s+$//g;
        if ( $line =~ /^\d+/g ) {
            my (
                $pkts, $bytes,  $target, $prot, $opt, $tosa,
                $tosb, $ifname, $src,    $dst,  $port
            ) = split( /\s+/, $line );
            ( $dst, my $junk ) = split( /\//, $dst );
            if ( exists( $local{$dst} ) ) {
                $traffin{$dst} = $bytes;
            }
        }
        $line = <IN>;
    }
    close IN;
    open( OUT, "$rkeys{F} -vxnL SASACCTO|" ) || croak('F option incorrect');
    $line = <OUT>;
    while ( defined($line) ) {
        $line =~ s/^\s+|\s+$//g;
        if ( $line =~ /^\d+/g ) {
            my (
                $pkts, $bytes,  $target, $prot, $opt, $tosa,
                $tosb, $ifname, $src,    $dst,  $port
            ) = split( /\s+/, $line );
            ( $src, my $junk ) = split( /\//, $src );
            if ( exists( $local{$src} ) ) {
                $traffout{$src} = $bytes;
            }
        }
        $line = <OUT>;
    }
    my $i;
    my $time = time();
    if ( $userrd == 1 || $logrrd == 1 ) {
        if ( $inetd == 0 ) {
            require 'RRDs.pm';
            my $updaterrd = 1;
            foreach $i ( keys %traffin ) {
                if ( !stat( "$rkeys{D}/$i" . ".rrd" ) ) {
                    &create_file($i);
                    $updaterrd = 0;
                }
                if (   stat( "$rkeys{D}/$i" . ".rrd" )
                    && $updaterrd == 1
                    && $logrrd == 1 )
                {
                    RRDs::update( "$rkeys{D}/$i.rrd",
                        "$time:$traffin{$i}:$traffout{$i}" );
                    syslog( 'info', "updated rrd file for $i" )
                      if ( $debug == 1 );
                }
                graph($i) if ( $userrd == 1 );
            }
        }
    }
    foreach $i ( keys %traffin ) {
        if ( $inetd == 1 ) {
            print STDOUT ("$system_time\t$i\t$traffin{$i}\t$traffout{$i}\n");
        }
        else {
            if ( $traffin{$i} != 0 && $traffout{$i} != 0 ) {
                open( LOG, "+>>$rkeys{D}/$i" )
                  || croak('Cannot open file for writing.Check D option');
                print LOG ("$system_time\t$i\t$traffin{$i}\t$traffout{$i}\n");
                syslog( 'info', "updated info for $i\n" ) if ( $debug == 1 );
            }
        }
    }
    close OUT;
    close LOG;
}

##############################################################
# OpenBSD 3.0 - pf support
# The way we take the traffic info is similar to those
# methods we use with ipchains and iptables. Execute
# pfctl with -s rules -v option to see the traffic per rule
# wich is simple pass. It's working fine for me but needs more
# testing especialy in combination with other rules.
# TODO: Make more tests or find another way to
#	get the values needed.
##############################################################
#			pf
#
sub pf() {
    open( PF, "$rkeys{F} -s rules -v|" ) || croak('F option incorrect');
    my ( $src, $dst, $bytes );
    $bytes = 0;
    while (<PF>) {
        if ( $_ =~ /pass/ .. /\]/ ) {
            if (/from\s+(.*)\s/) {
                ( $src, my $to, $dst ) = split( /\s|\t/, $1 );
            }
            if (/Bytes:\s+(.*)\s+\]/) { $bytes = $1; }
            ( $dst, my $junk ) = split( /\//, $dst );
            ( $src, $junk ) = split( /\//, $src );
            $traffin{$dst}  += $bytes if ( exists( $local{$dst} ) );
            $traffout{$src} += $bytes if ( exists( $local{$src} ) );
        }
    }
    my $i;
    my $time = time();
    if ( $userrd == 1 || $logrrd == 1 ) {
        if ( $inetd == 0 ) {
            require 'RRDs.pm';
            my $updaterrd = 1;
            foreach $i ( keys %traffin ) {
                if ( !stat( "$rkeys{D}/$i" . ".rrd" ) ) {
                    &create_file($i);
                    $updaterrd = 0;
                }
                if (   stat( "$rkeys{D}/$i" . ".rrd" )
                    && $updaterrd == 1
                    && $logrrd == 1 )
                {
                    RRDs::update( "$rkeys{D}/$i.rrd",
                        "$time:$traffin{$i}:$traffout{$i}" );
                    syslog( 'info', "updated rrd file for $i" )
                      if ( $debug == 1 );
                }
                graph($i) if ( $userrd == 1 );
            }
        }
    }
    foreach $i ( keys %traffin ) {
        if ( $inetd == 1 ) {
            print STDOUT ("$system_time\t$i\t$traffin{$i}\t$traffout{$i}\n");
        }
        else {
            if ( $traffin{$i} != 0 && $traffout{$i} != 0 ) {
                open( LOG, "+>>$rkeys{D}/$i" )
                  || croak('Cannot open file for writing.Check D option');
                print LOG ("$system_time\t$i\t$traffin{$i}\t$traffout{$i}\n");
                syslog( 'info', "updated info for $i" ) if ( $debug == 1 );
            }
        }
    }
    close PF;
    close LOG;
}

########################################
# Get's data via remote running sasacct
# TODO: more testing maybe
sub get_remote() {
    for (@remote) {
        use IO::Socket::INET;
        my $sockobj;
        my ( $host, $port ) = split( /:/, $_ );
        $sockobj = IO::Socket::INET->new(
            PeerAddr => $host,
            PeerPort => $port || 1234 || 'sasacct',
            Proto    => 'tcp',
            Type     => SOCK_STREAM
        );
        if ( !defined($sockobj) ) {
            syslog( 'warning', "Can't connect to $_: $!" ) if ( $debug == 1 );
            next;
        }
        while (<$sockobj>) {
            chop $_;
            my ( $date, $time, $ip, $in, $out ) = split( /\s+|\t+/, $_ );
            if ( $_ =~ /^\d/ ) {
                $traffin{$ip}  += $in;
                $traffout{$ip} += $out;
            }
        }
    }
    my $i;
    my $time = time();
    if ( $userrd == 1 || $logrrd == 1 ) {
        require 'RRDs.pm';
        my $updaterrd = 1;
        foreach $i ( keys %traffin ) {
            if ( !stat( "$rkeys{D}/$i" . ".rrd" ) ) {
                &create_file($i);
                $updaterrd = 0;
            }
            if (   stat( "$rkeys{D}/$i" . ".rrd" )
                && $updaterrd == 1
                && $logrrd == 1 )
            {
                RRDs::update( "$rkeys{D}/$i.rrd",
                    "$time:$traffin{$i}:$traffout{$i}" );
                syslog( 'info', "updated rrd file for $i" ) if ( $debug == 1 );
            }
            graph($i) if ( $userrd == 1 );
        }
    }
    foreach $i ( keys %traffin ) {
        if ( $traffin{$i} != 0 && $traffout{$i} != 0 ) {
            open( LOG, "+>>$rkeys{D}/$i" )
              || croak('Cannot open file for writing.Check D option');
            print LOG ("$system_time\t$i\t$traffin{$i}\t$traffout{$i}\n");
            syslog( 'info', "updated info for $i" ) if ( $debug == 1 );
        }
    }
}

##############################################################
# Generates graphics using Tobias Oetiker's rrdtool
# The 'G' key must point to valid directory where files will
# be stored named with the ip folowed by a dash and the word
# day,week,month and year. After making this run htmlmaker.plx
# to make html file for every host you're monitoring.
# Install rrdtool with 'make site-perl-install' in order to
# put the RRDs module in the perl's @INC.

sub create_file($) {
    my ($fname) = @_;
    require 'RRDs.pm';
    RRDs::create(
        "$rkeys{D}" . "$fname" . ".rrd", "DS:in:ABSOLUTE:600:U:U",
        "DS:out:ABSOLUTE:600:U:U",       "RRA:AVERAGE:0.5:1:600",
        "RRA:AVERAGE:0.5:6:700",         "RRA:AVERAGE:0.5:24:775",
        "RRA:AVERAGE:0.5:288:797",       "RRA:MAX:0.5:1:600",
        "RRA:MAX:0.5:6:700",             "RRA:MAX:0.5:24:775",
        "RRA:MAX:0.5:288:797",           "RRA:MIN:0.5:1:600",
        "RRA:MIN:0.5:6:700",             "RRA:MIN:0.5:24:775",
        "RRA:MIN:0.5:288:797",           "RRA:LAST:0.5:1:600",
        "RRA:LAST:0.5:6:700",            "RRA:LAST:0.5:24:775",
        "RRA:LAST:0.5:288:797"
    );
    syslog( 'warning', "RRDFile for $fname created!\n" );
    my $ERROR = $RRDs::error;
    if ($ERROR) {
        syslog( 'warning', "ERROR:$ERROR\n" );
    }
}

sub dographonly() {
    require 'RRDs.pm';
    use File::stat qw(:FIELDS);
    opendir( DIR, "$rkeys{D}" );
    my @files = readdir(DIR);
    for (@files) {
        if ( $_ =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(\_\d)*?\.rrd$/g ) {

            # give me the modification time of the rrd file
            stat( "$rkeys{D}" . "$_" ) or croak("cant stat $_: $!");

            #graph if rrd was modified since last week
            my $needgraph = time() - 604800;
            if ( $needgraph <= $st_mtime ) {
                s/\.rrd//g;
                graph($_);
            }
        }
    }
}

#######################################
# Graphs graphics using rrdtool by
# Tobi Oetiker.
# Hints: adding  "--lazy" to @header_str
#        will reduce cpu load when generating graphics
#        adding "--alg-x-mrtg" will make them
#	 look like mrtg (some of the people
#        are confuzed when you change the look & feel when switching
#        from mrtg to something that makes graphs with rrdtool)

sub graph($) {
    my ($fname) = @_;

    #check for directory for graphics
    my $graphdir;
    if ( -d $rkeys{G} ) {
        $graphdir = $rkeys{G};
    }
    else {
        syslog( 'warning',
            'skipping graphs: directory not found!Check G option.' );
        return;
    }
    my $target   = "$graphdir" . "$fname";
    my $fpathrrd = "$rkeys{D}" . "$fname" . ".rrd";
    my %t =
      ( day => 86000, week => 604800, month => 2600640, year => 31557600 );
    my %d = (
        day   => $locale{'day'},
        week  => $locale{'week'},
        month => $locale{'month'},
        year  => $locale{'year'}
    );
    my $topic;
    my $date = ctime( time() );
    my ( @header_str, @def_str, @data_str, @comment_str );

    if ( defined( $local{$fname}[0] ) ) {
        $topic = $local{$fname}[0];
    }
    else {
        $topic = $fname;
    }

    # define different DEF's for bits and bytes
    # *UNKNOWN* data will be rounded to 0.
    if ( $bits == 1 ) {
        @def_str = (
            "DEF:indatabits=$fpathrrd:in:AVERAGE",
            "DEF:outdatabits=$fpathrrd:out:AVERAGE",
            "CDEF:indata=indatabits,8,*",
            "CDEF:outdata=outdatabits,8,*",
            "CDEF:averagein=indata,UN,0,indata,IF",
            "CDEF:averageout=outdata,UN,0,outdata,IF"
        );
        push @header_str,
          (
            "--vertical-label", "$locale{'vertical-label-bits'}",
            "--base",           "1000",
            "--units-exponent", "3"
          );
    }
    else {
        @def_str = (
            "DEF:indatabytes=$fpathrrd:in:AVERAGE",
            "DEF:outdatabytes=$fpathrrd:out:AVERAGE",
            "CDEF:indata=indatabytes",
            "CDEF:outdata=outdatabytes",
            "CDEF:averagein=indatabytes,UN,0,indatabytes,IF",
            "CDEF:averageout=outdatabytes,UN,0,outdatabytes,IF"
        );
        push @header_str,
          ( "--vertical-label", "$locale{'vertical-label-bytes'}" );
    }
    @data_str = (
        "AREA:averagein#00CC00:$locale{in}",
        "GPRINT:indata:AVERAGE:$locale{'average'}\\:%8.2lf%s",
        "GPRINT:indata:MIN:$locale{'min'}\\:%8.2lf%s",
        "GPRINT:indata:MAX:$locale{'max'}\\:%8.2lf%s",
        "GPRINT:indata:LAST:$locale{'current'}\\:%8.2lf%s\\n",
        "LINE1:averageout#0000FF:$locale{out}",
        "GPRINT:outdata:AVERAGE:$locale{'average'}\\:%8.2lf%s",
        "GPRINT:outdata:MIN:$locale{'min'}\\:%8.2lf%s",
        "GPRINT:outdata:MAX:$locale{'max'}\\:%8.2lf%s",
        "GPRINT:outdata:LAST:$locale{'current'}\\:%8.2lf%s\\n"
    );

    #fix rrdtool 1.2.x incompatibility in comment
    $date =~ s/\:/\\:/g;
    @comment_str = ( "COMMENT:$locale{'comment'}\\c", "COMMENT:$date\\c" );
    for ( keys %t ) {
        push @header_str,
          (
            "--title", "$topic $d{$_} $locale{'title'}",
            "--start", "-$t{$_}",
            "-l",      "0",
            "--color", "FRAME#FFFFFF",
            "--color", "SHADEA#FFFFFF",
            "--color", "SHADEB#FFFFFF",
            "--color", "BACK#FFFFFF",
          );

        my ( $averages, $xsize, $ysize ) =
          RRDs::graph( "$target-$_.gif", @header_str, @def_str, @data_str,
            @comment_str );
        syslog( 'info',
            "image made: size ${xsize}x${ysize} target: $target-$_.gif" )
          if ( $debug == 1 && ${xsize} && ${ysize} );
        if ( my $ERROR = $RRDs::error ) {
            syslog( 'warning', "ERROR:$ERROR\n" );
        }
    }
}

#####################################################################
# The ipfstat part relys on ipf.rules existing in /etc.
# OpenBSD is true, but I don't know where this file is on other *BSD
# systems. For OpenBSD 3.0 we have our pf.conf in etc. Also
# edit the function bellow if needed.

sub reset($) {
    my ($prog) = @_;
    $| = 1;    # flush
    if ( $prog eq 'ipchains' ) {
        system( "$rkeys{F}", "-Z", "SASACCTI" );
        system( "$rkeys{F}", "-Z", "SASACCTO" );
        syslog( 'info', 'flushing rules' ) if ( $debug == 1 );
    }
    if ( $prog eq 'ipfstat' ) {

        #edit the place for your ipf.rules if not in etc
        system( "/sbin/ipf", "-F", "all", "-f", "/etc/ipf.rules" );
        syslog( 'info', 'flushing rules' ) if ( $debug == 1 );
    }
    if ( $prog eq 'iptables' ) {
        system( "$rkeys{F}", "-Z", "SASACCT" );
        syslog( 'info', 'flushing rules' ) if ( $debug == 1 );
    }
    if ( $prog eq 'pf' ) {
        system( "$rkeys{F}", "-F", "rules" );

        #edit the place for your pf.conf if not in etc
        system( "$rkeys{F}", "-R", "/etc/pf.conf" );
        syslog( 'info', 'flushing rules' ) if ( $debug == 1 );
    }
    if ( $? != 0 ) {
        carp("executing of $rkeys{F} failed.Exit Code: $?");
        syslog( 'warning', "executing of $rkeys{F} failed. Exit Code: $?" );
    }
}

sub usage {
    print "Usage: $0 [-hvslrgdi] [-c] [args]\n";
    print "  -h\thelp\n";
    print "  -v\tversion\n";
    print "  -c\tsupply path to configfile\n";
    print "  -s\tsummarize logfiles\n";
    print "  -l\tlog without graphics\n";
    print "  -r\tlog and update rrd file without graphics\n";
    print "  -g\tgenerate graphics only and exit\n";
    print "  -d\tverbose logging to syslog\n";
    print "  -i\tprints data to stdout (inetd/xinetd)\n";
    print "  -e\tget data from remote running sasacct\n";
    exit;
}

sub ver {
    print "sasacct (sasacct) 1.0.3\n\n";
    print "Written by Aleksandar Zhelyazkov\n";
    print "Copyright (C) 2003\n";
    print
"This is free software; see the source for copying conditions. There is NO\n";
    print
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
    exit;
}

sub summarizelogs {
    my @ips;
    if ( stat( $rkeys{D} ) ) {
        opendir DIR, $rkeys{D} || die("Cannot open: $!");
        my @files = readdir(DIR);
        closedir DIR;
        for (@files) {
            if (   $_ =~ /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(\_\d)*?$/
                && $_ !~ /rrd/g )
            {
                push @ips, $_;
                print $_, "\n";
            }
        }
    }
    my $ip;
    foreach $ip (@ips) {
        if ( stat( "$rkeys{D}" . "$ip" ) ) {
            open( IN, "<$rkeys{D}" . "$ip" )
              || carp("Error: $! or cannot open $ip");
            open( OUT, ">$rkeys{D}" . "$ip.summarized" )
              || carp("Error:$! or cannot open $ip");
            my ( $date, $time, $addr, $in, $out, %sum, @days, @months );
            while (<IN>) {
                ( $date, $time, $addr, $in, $out ) = split( /\s+|\t+/, $_ );
                $date =~ s/(\d{4})(\d{2})(\d{2})/$1 $2 $3/g;
                @months = qw(01 02 03 04 05 06 07 08 09 10 11 12);
                @days =
                  qw(01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31);
                for ( my $j = 0 ; $j < 31 ; $j++ ) {
                    for ( my $i = 0 ; $i < 12 ; $i++ ) {
                        if ( $2 eq $months[$i] && $3 eq $days[$j] ) {
                            $sum{ "$1" . "$months[$i]" . "$days[$j]" }[0] +=
                              $in;
                            $sum{ "$1" . "$months[$i]" . "$days[$j]" }[1] +=
                              $out;
                        }
                    }
                }
            }
            for ( sort keys %sum ) {
                print OUT ("$_\t000000\t$addr\t$sum{$_}[0]\t$sum{$_}[1]\n");
            }
            close IN;
            close OUT;
        }
        if ( stat( "$rkeys{D}" . "$ip.summarized" ) ) {
            use File::Copy;
            copy( "$rkeys{D}" . "$ip.summarized", "$rkeys{D}" . "$ip" );
            unlink( "$rkeys{D}" . "$ip.summarized" );
        }
    }
}
