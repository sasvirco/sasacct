#!/usr/bin/perl -w
# This script requires some aditional modules.
# RRDs - comes with rrdtool distribution. Make it availabe with 'make site-perl-install'
# Net-SNMP - available on CPAN
# Author - Alexander Jeliazkov - sasvirco@homemail.com
# http://rousse.pm.org/sastragraph/

use strict;
use Net::SNMP;
use Carp;
use RRDs;
use File::stat qw(:FIELDS);
use Sys::Syslog qw (:DEFAULT setlogsock);
use Time::localtime qw (:FIELDS);
use Getopt::Std;
use File::Basename;
use vars qw($session $error $response);

#global vars and defaults
my ( $name, $path ) = fileparse($0);
my $VERSION = '0.4 - sasacct 1.0.2';

#hash with configured hosts
my %snmp;
my $needlastupdate = 0;
my $logdir;      # directory to keep logfile and .rrd
my $graphdir;    #directory for graphics
my %last;        #hash with last known values
my %options;     #commandline
my %result;      #will have the information for the traffic
my $conf;        #configfile
my $now         = localtime();
my $system_time = sprintf(
    "%04d%02d%02d% 02d%02d%02d",
    $tm_year + 1900,
    $tm_mon + 1,
    $tm_mday, $tm_hour, $tm_min, $tm_sec
);
my $updaterrd = 1;
my $bits      = 1;    # 0 - bits, 1 - bytes
my %hostname;         #hostname{router}[clientname,intnum]
my $localedir;        #directory with language translations
my $lang          = 'C';          # language chosen
my $debug         = 0;            #0 no debug , 1 debug to syslog
my $interfacetype = 'numbers';    # interfacetype default to numbers

##############################
#locales
my %locale = (
    'day'                  => 'Daily',
    'week'                 => 'Weekly',
    'month'                => 'Montly',
    'year'                 => 'Yearly',
    'vertical-label-bits'  => 'Bits per second',
    'vertical-label-bytes' => 'Bytes per second',
    'in'                   => 'In',
    'average'              => 'Avg',
    'min'                  => 'Min',
    'max'                  => 'Max',
    'out'                  => 'Out',
    'current'              => 'Current',
    'comment' => 'Generated by sastragraph http\://rousse.pm.org/sastragraph',
    'title'   => 'Traffic Stats'
);

if ( !exists( $ENV{'LANG'} ) ) {
    $lang = 'C';
}
else {
    $lang = $ENV{'LANG'};
}

###########################
#syslog
setlogsock('unix');
openlog( 'sastragraph', 'cons,pid,nowait', 'user' );

############################
#command line options
getopts( 'hdvc:', \%options );
if ( defined( $options{h} ) ) { &usage; }
if ( defined( $options{v} ) ) { &version; }

#############################
#specify configfile
if ( defined( $options{c} ) ) {
    $conf = $options{c};
}
elsif ( stat( "$path" . "../etc/sastragraph.conf" ) ) {
    $conf = "$path" . "../etc/sastragraph.conf";
}
elsif ( stat('/etc/sastragraph.conf') ) {
    $conf = '/etc/sastragraph.conf';
}
else {
    croak('Supply configfile with -c ');
}

#debug
if ( defined( $options{d} ) ) {
    $debug = 1;
}

#Parse config file
&parse_conf();

# Update locales
# first look up ../lang/
if ( stat( "$path" . "/../lang/$lang" ) ) {
    $localedir = "$path" . "/../lang/";
}

# second look up values from config file
if ( defined($localedir) && stat( "$localedir" . "$lang" ) ) {
    open( LANG, "<$localedir" . "$lang" )
      or carp("Cannot open $localedir.$lang:$!");
    my ( $descr, $value );
    while (<LANG>) {
        next if $_ =~ /^#/g;
        next if $_ =~ /^\s+/g;
        chomp $_;
        ( $descr, $value ) = split( /=/, $_ );
        $locale{$descr} = $value;
    }
}

# workaround for not opening snmp
# sessions for each interface on the same router
my $key;
for $key ( keys(%snmp) ) {
    $hostname{ $snmp{$key}->[0] }->{'community'} = $snmp{$key}->[2];
    $hostname{ $snmp{$key}->[0] }->{'client'}->{$key} = $snmp{$key}->[1];
}

#########################
#		main 			#
#########################

# Generate last known counters
&gen_last();

# Open last file again in O_WRONLY for the new values to be stored
open( LAST, ">$logdir" . "last" ) || croak("Cannot open last:$!");

# Query the hosts
for ( keys(%hostname) ) {
    get_info($_);
}

# Call appropriate functions to save the values collected.
# If there is no such file, create it , else save the values and
# generate graphics

foreach ( keys %result ) {
    my $file = "$snmp{$_}->[0]" . "_" . "$snmp{$_}->[1]" . '.rrd';
    if ( stat( "$logdir" . "$file" ) ) {
        if ( $result{$_}->[0] != -1 && $result{$_}->[1] != -1 ) {
            &save_data($_);
            syslog( 'info', "Calling save_data() for client $_" )
              if ( $debug == 1 );
        }
        &create_graph($_);
        syslog( 'info', "Calling create_graph for client $_" )
          if ( $debug == 1 );
    }
    else {
        &create_file($_);
        syslog( 'info', "Calling create_file for $_" ) if ( $debug == 1 );

        #we do not update the rrd file the first time
        #it will be updated the second run but update the logfile
        $updaterrd = 0;
        if ( $result{$_}->[0] != -1 && $result{$_}->[1] != -1 ) {
            &save_data($_);
            syslog( 'info', "Calling save_data() for client $_" )
              if ( $debug == 1 );
        }
    }
}

#########################
#		functions		#
#########################

#read the config file
sub parse_conf {
    open( CONF, "<$conf" ) || croak("Cannot open file $conf: $!");
    while (<CONF>) {
        if ( $_ =~ /^snmp/ ) {
            chop $_;
            s/^snmp://g;
            my ( $client, @i ) = split( /:/, $_ );
            $snmp{$client} = \@i if !defined( $snmp{$client} );
        }
        if ( $_ =~ /^logdir/ ) {
            chop $_;
            s/^logdir://g;

            # Remove the "/" sufix if exists and add it again
            # fazzter than checking for it

            s/\/$//g;    # the black magic
            $_ = $_ . "\/"; # goes here,seems unusable but fixes pain in the ass
            $logdir = $_;
        }
        if ( $_ =~ /^graphdir/ ) {
            chop $_;
            s/^graphdir://g;
            s/\/$//g;
            $_        = $_ . "\/";
            $graphdir = $_;
        }
        if ( $_ =~ /^localedir/ ) {
            chop $_;
            s/^localedir://g;
            s/\/$//g;
            $_         = $_ . "\/";
            $localedir = $_;
        }
        if ( $_ =~ /^language/ ) {
            chomp $_;
            s/^language://g;
            $lang = $_;
        }
        if ( $_ =~ /^interfacetype/ ) {
            s/^interfacetype://g;
            $interfacetype = $_;
        }
    }
    close CONF;
}

# generate the last values
# if our accounting machine was offline due to restart or power failure
# for more than 15 minutes consider that we query the host for the first time
# we loose some traffic again ;(
# TODO: Think for better algorithm !!!
sub gen_last {
    return if ( !stat( "$logdir" . "last" ) );
    stat( "$logdir" . "last" );
    my $nowtime = time();
    if ( ( $now - $st_ctime ) > 900 ) {
        print(
            "Lastfile ctime greater than 900 seconds consider values unknown!\n"
        );
        return;
    }
    open( LAST, "<$logdir" . "last" ) || croak("Cannot open last:$!");
    while (<LAST>) {
        my ( $ipint, @bytes ) = split( /:/, $_ );
        $last{$ipint} = \@bytes;
    }
    close LAST;
}

# Make snmp query and collect the counters
sub get_info {
    my ($router) = @_;
    my ( $inbytes, $outbytes, $clientid, $interface );

    # interfaces.ifTable.ifEntry.if[In|Out]Octets
    my $ifInOctets  = ".1.3.6.1.2.1.2.2.1.10.";
    my $ifOutOctets = ".1.3.6.1.2.1.2.2.1.16.";

    # interfaces.ifTable.ifEntry.ifDescr
    my $ifDescr = ".1.3.6.1.2.1.2.2.1.2";

    ######################################
    # SNMP connection
    my ( $s, $e ) = Net::SNMP->session(
        Hostname  => $router,
        Community => $hostname{$router}->{community},
        Port      => 161,
    );

    if ( !defined($s) ) {
        print("Cannot Connect to $router: $!\n");
        syslog( 'info', "Cannot Connect to $router: $!" ) if ( $debug == 1 );
        exit 1;
    }
    ########################################################
    # interface numbers to interface description mapping
    my ( $descr2int_map, %int2descr_map );
    if ( $interfacetype =~ /descriptions/ ) {
        $descr2int_map = $s->get_table("$ifDescr");
        foreach ( sort keys(%$descr2int_map) ) {
            $_ =~ /(\d+)$/g;
            $int2descr_map{"$$descr2int_map{$_}"} = $1;
        }
    }
    foreach $clientid ( keys( %{ $hostname{$router}->{'client'} } ) ) {
        if ( $interfacetype =~ /descriptions/ ) {
            my $intdescr = $hostname{$router}->{client}->{$clientid};
            $interface =
              $int2descr_map{"$hostname{$router}->{client}->{$clientid}"};
        }
        else {
            $interface = $hostname{$router}->{client}->{$clientid};
        }
        if ( !defined( my $r = $s->get_request( $ifInOctets . $interface ) ) ) {
            printf( "get_info:get_request for $router: %s.\n", $s->error() );
            syslog( 'info',
                "get_info:failed get_request $router.'_'.$interface" )
              if ( $debug == 1 );
            $s->close();
            $inbytes = "-1";
        }
        else {
            $inbytes = $r->{ "$ifInOctets" . "$interface" };
        }
        if ( !defined( my $r = $s->get_request( $ifOutOctets . $interface ) ) )
        {
            printf( "get_info:get_request for $router: %s.\n", $s->error() );
            syslog( 'info',
                "get_info:failed get_request $router.'_'.$interface" )
              if ( $debug == 1 );
            $s->close();
            $outbytes = "-1";
        }
        else {
            $outbytes = $r->{ "$ifOutOctets" . "$interface" };
        }
        $result{$clientid}->[0] = $inbytes;
        $result{$clientid}->[1] = $outbytes;
    }
}

#Update RRD with time:input:output values
sub save_data {
    my ($client) = @_;
    my $now_ptr  = $result{$client};
    my $ipint    = "$snmp{$client}->[0]" . "_" . "$snmp{$client}->[1]";
    my $input    = 0;
    my $output   = 0;
    my $last_ptr;
    my $time = time();

    #if we query the host for the first time log the value
    #in the last file and return. rrd file and logfile will
    #be updated next time

    if ( defined( $last{$ipint} ) ) {
        $last_ptr = $last{$ipint};
    }
    else {
        print LAST ("$ipint:$now_ptr->[0]:$now_ptr->[1]\n");
        return;
    }
    print LAST ("$ipint:$now_ptr->[0]:$now_ptr->[1]\n");
    if (   ( $last_ptr->[0] < $now_ptr->[0] )
        && ( $last_ptr->[1] < $now_ptr->[1] ) )
    {
        $input  = $now_ptr->[0] - $last_ptr->[0];
        $output = $now_ptr->[1] - $last_ptr->[1];
    }
    if (   ( $last_ptr->[0] > $now_ptr->[0] )
        && ( $last_ptr->[1] > $now_ptr->[1] ) )
    {
        $input  = $now_ptr->[0];
        $output = $now_ptr->[1];

    }
    if (   ( $last_ptr->[0] == $now_ptr->[0] )
        && ( $last_ptr->[1] == $now_ptr->[1] ) )
    {
        $input  = 0;
        $output = 0;
    }
    if ( stat( "$logdir" . "$ipint.rrd" ) ) {
        RRDs::update( "$logdir" . "$ipint.rrd", "$time:$input:$output" )
          if ( $updaterrd == 1 );
        if ( my $ERROR = RRDs::error ) {
            syslog( 'info', "Error in save_data(): $ERROR" ) if ( $debug == 1 );
        }
    }
    open( LOG, ">>$logdir" . "$ipint" )
      or croak("Cannot open logfile for $ipint: $!");
    print LOG ("$system_time\t$ipint\t$input\t$output\n")
      if ( $input != 0 || $output != 0 );
    close LOG;
}

#Create rrd file if does not exist
sub create_file {
    my ($client) = @_;
    my $fname = "$snmp{$client}->[0]" . "_" . "$snmp{$client}->[1]" . '.rrd';
    RRDs::create(
        "$logdir" . "$fname",      "DS:in:ABSOLUTE:600:U:U",
        "DS:out:ABSOLUTE:600:U:U", "RRA:AVERAGE:0.5:1:600",
        "RRA:AVERAGE:0.5:6:700",   "RRA:AVERAGE:0.5:24:775",
        "RRA:AVERAGE:0.5:288:797", "RRA:MAX:0.5:1:600",
        "RRA:MAX:0.5:6:700",       "RRA:MAX:0.5:24:775",
        "RRA:MAX:0.5:288:797",     "RRA:LAST:0.5:1:600",
        "RRA:LAST:0.5:6:700",      "RRA:LAST:0.5:24:775",
        "RRA:LAST:0.5:288:797"
    );
    if ( my $ERROR = RRDs::error ) {
        syslog( 'info', "Error in create_file():$ERROR" ) if ( $debug == 1 );
    }
}

#Create Graphics
sub create_graph {
    my ($client) = @_;
    my $fname = "$snmp{$client}->[0]" . '_' . "$snmp{$client}->[1]" . '.rrd';
    my $target =
      "$graphdir" . "$snmp{$client}->[0]" . '_' . "$snmp{$client}->[1]";
    my %t =
      ( day => 86000, week => 604800, month => 2600640, year => 31557600 );
    my %d = (
        day   => $locale{'day'},
        week  => $locale{'week'},
        month => $locale{'month'},
        year  => $locale{'year'}
    );
    my ( @header_str, @def_str, @data_str, @comment_str );
    my $fpathrrd = "$logdir" . "$fname";
    my $date     = ctime( time() );

    if ( $bits == 1 ) {
        @def_str = (
            "DEF:indatabits=$fpathrrd:in:AVERAGE",
            "DEF:outdatabits=$fpathrrd:out:AVERAGE",
            "CDEF:indata=indatabits,8,*",
            "CDEF:outdata=outdatabits,8,*",
            "CDEF:averagein=indata,UN,0,indata,IF",
            "CDEF:averageout=outdata,UN,0,outdata,IF"
        );
        push @header_str,
          (
            "--vertical-label", "$locale{'vertical-label-bits'}",
            "--base",           "1000"
          );
    }
    else {
        @def_str = (
            "DEF:indatabytes=$fpathrrd:in:AVERAGE",
            "DEF:outdatabytes=$fpathrrd:out:AVERAGE",
            "CDEF:indata=indatabytes",
            "CDEF:outdata=outdatabytes",
            "CDEF:averagein=indatabytes,UN,0,indatabytes,IF",
            "CDEF:averageout=outdatabytes,UN,0,outdatabytes,IF",
        );
        push @header_str,
          ( "--vertical-label", "$locale{'vertical-label-bytes'}" );
    }
    @data_str = (
        "AREA:averagein#00CC00:$locale{'in'}",
        "GPRINT:averagein:AVERAGE:$locale{'average'}\\:%8.2lf%s",
        "GPRINT:indata:MIN:$locale{'min'}\\:%8.2lf%s",
        "GPRINT:indata:MAX:$locale{'max'}\\:%8.2lf%s",
        "GPRINT:indata:LAST:$locale{'current'}\\:%8.2lf%s\\n",
        "LINE1:averageout#0000FF:$locale{'out'}",
        "GPRINT:averageout:AVERAGE:$locale{'average'}\\:%8.2lf%s",
        "GPRINT:outdata:MIN:$locale{'min'}\\:%8.2lf%s",
        "GPRINT:outdata:MAX:$locale{'max'}\\:%8.2lf%s",
        "GPRINT:outdata:LAST:$locale{'current'}\\:%8.2lf%s\\n"
    );
    @comment_str = ( "COMMENT:$locale{'comment'}\\c", "COMMENT:$date\\c" );
    for ( keys %t ) {
        push @header_str,
          (
            "--title", "$snmp{$client}->[3] $d{$_} $locale{'title'}",
            "--start", "-$t{$_}",
            "-l",      "0",
            "--color", "FRAME#FFFFFF",
            "--color", "SHADEA#FFFFFF",
            "--color", "SHADEB#FFFFFF",
            "--color", "BACK#FFFFFF",
          );
        RRDs::graph( "$target-$_.gif", @header_str, @def_str, @data_str,
            @comment_str );
        if ( my $ERROR = RRDs::error ) {
            syslog( 'warning', "ERROR:$ERROR\n" );
        }
    }
}

#print version info
sub version {
    print "sastragraph (sasacct 1.0.2) 0.4\n\n";
    print "Written by Aleksandar Zhelyazkov\n";
    print "Copyright (C) 2003\n";
    print
"This is free software; see the source for copying conditions. There is NO\n";
    print
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n";
    exit;
}

#print help
sub usage {
    print("$0 Usage:\n");
    print("\t-c suplly configfile from comand line\n");
    print("\t-v print version information\n");
    print("\t-h print usage information and exit\n");
    print("\t-d print debugging information to syslog\n");
    exit;
}
